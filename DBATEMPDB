A query that used to run in 2 seconds is now taking 2 minutes — walk me through how you’d troubleshoot and resolve it?
- Confirm scope and baseline:
- Compare current vs past execution plans and runtime metrics; check if data volume, stats, indexes, or schema changed.
- Use Query Store to pull runtime regression and plan differences.
- Check waits and resource profile:
- Use sys.dm_exec_requests for wait_type, blocking_session_id, and tempdb spills warnings; correlate with sys.dm_os_wait_stats.
- Inspect the current execution plan:
- Look for missing indexes, scans vs seeks, cardinality estimate mismatches, spills (Sort/Hash warnings), implicit conversions, and parameter sniffing.
- Immediate fixes (safe and targeted):
- Update stats on involved tables/indexes if stale.
- Add or tune indexes (covering, filtered) if plan shows scan/lookup bottlenecks.
- Eliminate spills by increasing memory grant via query rewrite or appropriate indexes.
- Address parameter sniffing using OPTION(RECOMPILE), OPTIMIZE FOR, or plan forcing via Query Store (temporary).
- Remove implicit conversions by aligning data types and SARGable predicates.
- Validate improvement:
- Rerun under similar conditions; confirm reduced waits, stable plan, and runtime within target.
---------------------------------------------------------------------------------------------------------------------------
You see CPU usage at 100% on the SQL Server instance. How do you isolate the cause?
- Isolate top CPU consumers:
- Per‑query CPU: sys.dm_exec_query_stats with text/plan.
- Active requests: sys.dm_exec_requests sorted by cpu_time.
- Check wait profile and non‑SQL CPU:
- If waits are SOS_SCHEDULER_YIELD, it’s CPU saturation; if not, bottleneck may be elsewhere.
- Confirm external CPU consumers (AV scans, external processes) at the OS level.
- Mitigate quickly:
- Fix hot queries (indexes, rewrite, remove scalar UDFs, reduce rowset).
- Enable in‑memory temp optimizations (e.g., reduce spills).
- Right‑size MAXDOP and Cost Threshold for Parallelism to balance parallelism overhead.
- Cache efficiency: avoid excessive ad‑hoc plans; consider forced parameterization or “Optimize for ad hoc workloads”.
-----------------------------------------------------------------------------------------------------------------------------
Users complain of blocking/locking; multiple sessions are stuck. How do you find which queries/blockers and resolve the situation?
- Identify blockers and blocked chains:
- Use sys.dm_exec_requests (blocking_session_id) and sys.dm_tran_locks to map chains.
- Find the root blocker:
- Sessions with blocking_session_id = 0 but others pointing to them are your blockers; inspect their transaction state, isolation level, and open_tran_count.
- Resolve safely:
- Short‑term: If business‑approved, KILL the session of the root blocker after assessing the rollback impact.
- Mitigation: Implement RCSI (READ COMMITTED SNAPSHOT) to reduce read‑write blocking for OLTP workloads.
- Tuning: Reduce transaction scope/duration, commit sooner, avoid “BEGIN TRAN” around slow queries, and ensure indexes support seek‑based access.
---------------------------------------------------------------------------------------------------------------------------
You detect frequent deadlocks in your OLTP database. What steps do you take to analyze, resolve, and prevent future deadlocks?
- Capture and analyze deadlocks:
- Use Extended Events “xml_deadlock_report” to get the graph; identify resource order and victim.
- Look for patterns: same tables accessed in different order, missing indexes, long‑running range scans, or wide updates.
- Fix patterns:
- Consistent object order across procedures to avoid cyclical waits.
- Add supporting indexes to narrow lock footprint (seek vs scan).
- Reduce transaction time; move expensive computations outside the transaction.
- Use row‑versioning (RCSI/SNAPSHOT) for read workloads when appropriate.
- Locking hints as a last resort: UPDLOCK, ROWLOCK, or SERIALIZABLE only when justified.
- Preventive controls:
- Code reviews for transactional order, monitor with XE, alert on spikes, and track Query Store for affected statements
-------------------------------------------------------------------------------------------------------------------------------

https://www.youtube.com/watch?v=AKzxj95qBV8

https://www.youtube.com/watch?v=zoBeyv3Asl0

https://youtu.be/LGLuHYHbCFA?si=qozKOBUcUHguoEMh --github

P T
https://youtu.be/xuxgxdbCPnY?si=KupdvfqKoeJjv5r8 

https://youtu.be/HvxmF0FUwrM?si=XV4bN6zXOsyV_xVn

https://youtu.be/FoTMJFZ4wwg?si=CU09Rvfw-oi-D3Oi
1.what are your responsibilities as a PostgreSQL database administrator? 
pg_stat_activity;
Daily Tasks
	• Backups: Typically incremental or cumulative, with weekly full backups; logs are archived and emailed to the DBA upon failure.
	• Database Alert Logs: Monitor for ERROR and FATAL logs, with automatic notifications via email or pagers.
	• Operating System File Space, CPU, and I/O Statistics: Regular monitoring depending on system admin support.
	• SQL Tuning Sets: Review the top 5 to 10 SQL statements.
	• Tablespace Growth: Monitor extensions, partition management, and temporary tablespace.
	• Replication: Ensure log shipping/application is in sync.
	• Alert Logs: Monitor for intrusion detection and remove unused accounts.
	• New Account Creation: Automate the process as much as possible.
	• Personnel Security Changes: Require at least 24 hours' notice.
	• Migrate Schema and Code Changes or Ad Hoc SQL Updates.
	• Large Table Growth: Manage coalescing tablespace.
	• Daily Change Log: Keep a log of daily changes to the database and share with relevant IT staff.
Weekly Tasks
	• Backups: Usually full backups.
	• Cloning for Non-Production Databases: Automate or script the process.
	• Tablespace Growth: Roll up daily monitoring to weekly.
	• Patches/Upgrades: Implement milestone updates.
Monthly Tasks
	• Cloning for Non-Production Databases: Automate or script the process.
	• Tablespace Growth Monitoring: Roll up weekly monitoring to monthly.
	• Trends and Forecasts: Analyze CPU utilization, I/O stats, and logons.
	• Password Changes on Production: Update for sys, system, and schema accounts.
	• Practicing Recovery Scenarios.
Quarterly Tasks
	• Database Upgrades.
	• Monitoring Tablespace Growth: Roll up monthly monitoring to yearly.
Yearly Tasks
	• Tablespace Growth: Generate a yearly report.
	• Trends and Forecast Rollups.
	• Attend PostgreSQL Conferences: Participate in regional or national pgconf groups.
	• PostgreSQL Upgrades: Plan upgrades with downtime.
	• Software Licensing and Warranty Renewals.
	• Hardware Evaluation and Replacement.
SSL Certificate Renewals.

